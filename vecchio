
    "#LEO Hashfunction family\n",
    "\n",
    "N_SHINGLES = 40318\n",
    "\n",
    "# cardinality is the number of the hashfunctions we want to generate \n",
    "cardinality=100\n",
    "N_PRIME = 40343 #first prime number after 40318\n",
    "N_PRIME = 40993 # nearest prime to 41000\n",
    "def hashfunction_family(number_of_hashfunctions=cardinality):\n",
    "    '''\n",
    "    create a family of #number_of_hashfunctions hashfunctions\n",
    "\n",
    "    INPUT: number of hashfunctions we want to genrate\n",
    "    OUTPUT: parameters  alpha and beta that univocally identificate the hashfunction family\n",
    "    '''\n",
    "\n",
    "    n=N_PRIME\n",
    "    np.random.seed(seed=124)\n",
    "    params_alpha = np.random.randint(0, n, number_of_hashfunctions)\n",
    "    params_beta=np.random.randint(0, n, number_of_hashfunctions)\n",
    "\n",
    "    return params_alpha,params_beta,n\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [],
   "source": [
    "alpha,beta,n=hashfunction_family(100)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Since our hashfunctions will be of the form $ h(x)_{i}= (\\alpha*x+ \\beta ) \\mod{n} $ where x is the index of the row, $ \\alpha $ and $ \\beta $ identificates univocally the hashfunction"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 6. create signature matrix"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    " The principle is to create a new matrix ,called signature matrix, that has (100,#songs) as dimensions starting from the initial matrix applying the family of hashfunctions instead of permutations of the rows.\n",
    " We initialize the signature matrix with inf value.\n",
    " Looking at the rows of the initial matrix sequently, we consider just the elements !=0  and we compute every hashfunction of the family defined before: if the value of the hashfunction for that rows is smaller that S($ h_{i} , song_{j}$), we substitute  S($ h_{i} , song_{j}$) with the current value of the hashfunction"
    "alpha,beta=hashfunction_family()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 188,
   "metadata": {},
   "outputs": [],
   "source": [
    "def hash_row(index_row):\n",
    "    '''\n",
    "    compute the value of all the hashfunctions for the row\n",
    "    INPUT= index_row\n",
    "    OUTPUT=hashfunctions values\n",
    "    '''\n",
    "    a=params_alpha\n",
    "    b=params_beta\n",
    "    mod=n\n",
    "    hash_values=[]\n",
    "    for i in range (len(alpha)):\n",
    "        ris=(index_row*a[i]+b[i])%mod\n",
    "        hash_values.append(ris)\n",
    "    return hash_values"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 226,
   "metadata": {},
   "outputs": [],
   "source": [
    "signature_matrix = np.matrix(np.ones((100,len(track_vocabulary))) * np.inf)\n",
    "rows_S,cols_S=signature_matrix.shape\n",
    "\n",
    "rows,cols=initial_matrix.shape\n",
    "for row_index in range (rows):#(rows):\n",
    "    #for col_index in range(cols):\n",
    "    div=np.where(initial_matrix[row_index,:]==1)\n",
    "    index_non_null=div[0]\n",
    "\n",
    "    #compute the hashfunction for this row\n",
    "    hash_values=hash_row(row_index)\n",
    "\n",
    "    #substitute elements in signature matrix if hash < sign[i][j]\n",
    "    for i in range(len(hash_values)):\n",
    "        for j in index_non_null:\n",
    "            if (j==1413):\n",
    "                print('ecco',i,row_index)\n",
    "            if signature_matrix[i,j]>hash_values[i]:\n",
    "                signature_matrix[i,j]=hash_values[i]\n",
    "    \n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 228,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''\n",
    "div=np.where(initial_matrix[:,27]==1)\n",
    "index_non_null=div[0]\n",
    "#index_non_null\n",
    "\n",
    "div=np.where(initial_matrix[:,27]==1)\n",
    "div\n",
    "'''\n",
    "\n",
    "'''\n",
    "m=np.matrix([[1,0,1],[0,1,1],[1,1,1]])\n",
    "cerco=np.where(m[:,0]==1)\n",
    "nuovo=cerco[0]\n",
    "nuovo[1]\n",
    "''';\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 234,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[  48.  243.  438. ...  532.  734.  369.]\n",
      " [  22.  178.  490. ... 1688.  283.   13.]\n",
      " [ 945.  172.  193. ...  151. 1886. 1450.]\n",
      " ...\n",
      " [ 157.  216.  275. ...   98.    3.  629.]\n",
      " [ 466.  523.  618. ...  371.  469.  163.]\n",
      " [ 502.  342.  262. ...   46.  623. 1103.]]\n"
     ]
    }
   ],
   "source": [
    "print(signature_matrix)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# 8.Jaccart similarity"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "signature=signature_matrix\n",
    "#hashed_quey Ã¨  numpy.array\n",
    "def jaccard(signature_col,hashed_query):\n",
    "    similar=0\n",
    "    for i in range(len(hashed_query)):\n",
    "        if signature_col[i]==hashed_query[i]:\n",
    "            similar+=1\n",
    "    similarity_score=similar/(2*len(hashed_query)-similar)\n",
    "    \n",
    "    return similarity_score\n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def retrieve_match(signature,hashed_query):\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 241,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(100, 1413)"
      ]
     },
     "execution_count": 241,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "signature_matrix.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 240,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 240,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "a=np.array([1,2,3,4,5])\n",
    "a[1]"
   ]
  },